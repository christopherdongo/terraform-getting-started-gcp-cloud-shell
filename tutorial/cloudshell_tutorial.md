# Getting Started with Terraform on Google Cloud Platform

## Introduction

### About this Tutorial

This tutorial will help you quickly learn the fundamentals of Terraform and how
to provision infrastructure on Google Cloud Platform (GCP).

As you follow this tutorial, you'll use Terraform to provision, update, and
destroy a simple set of infrastructure using the sample configuration provided.

The sample configuration provisions a resource group, networking resources and
rules, storage, and a basic Linux virtual machine. You'll also learn about
Terraform modules, remote backends, outputs, and provisioners. These are the
building blocks you will use to create Terraform configurations.

### Google Cloud Shell

This tutorial uses Google Cloud Shell to give you an environment preconfigured
with Terraform. You can execute commands at the command prompt, and edit the
files in the editor window.

If you'd prefer to follow this tutorial on your local machine, you can follow
[this collection on
learn.hashicorp.com](https://learn.hashicorp.com/collections/terraform/gcp-get-started).

## Install Terraform

Terraform is already installed in your Cloud Shell environment. You can verify
this with the `terraform version`.

```bash
terraform version
```

**Note:** When you run the previous command, Terraform may print a warning that
  there is a newer version of Terraform available. This tutorial has been tested
  with the version of Terraform installed in your Cloud Shell environment, so
  you can continue to use it for the rest of the tutorial.

## Set Up GCP

In order to provision GCP infrastructure with Terraform, you will need an
account and a GCP project.

In this tutorial, you will build infrastructure on
[GCP](https://cloud.google.com), but Terraform can manage many other things
using [providers](https://www.terraform.io/docs/providers/index.html). Some
examples of this are in the [use cases
section](https://www.terraform.io/intro/use-cases.html).

### Warning: Cost

While everything provisioned in this guide should fall within GCP's free tier,
if you provision resources outside of the free tier, you may be charged. We
cannot be responsible for any charges you may incur.

### Create GCP Project

In addition to a GCP account, you will need to use a **GCP Project** to follow
this guide.

In order to keep the resources you will create in this tutorial separate from
your other resources, we recommend that you create a new project to use
throughout the tutorial.

After you have created the project, select it below.

<walkthrough-project-billing-setup></walkthrough-project-billing-setup>

Selecting the project here will set the project ID in future steps, so be sure
to select a project before moving on!

#### Authentication

When you are using Google Cloud Shell, the shell is already configured with
access to your GCP credentials, so you will not need to do anything extra to
authenticate and start provisioning resources. When using Terraform from another
environment, you will need to configure authentication. You can read about
credentials in the [GCP provider
documentation](https://www.terraform.io/docs/providers/google/provider_reference.html#credentials).

## Terraform Configuration

The set of files used to describe infrastructure in Terraform is known as a
Terraform _configuration_. You will write configuration now to
launch a single GCP instance.

The format of Terraform configuration is [documented
here](https://www.terraform.io/docs/configuration/index.html). Terraform
configuration can also be [written in
JSON](https://www.terraform.io/docs/configuration/syntax.html), but we recommend
only using JSON when the configuration is generated by a machine.

The entire configuration is included below.

When you run Terraform commands, Terraform will load all configuration files
from the current directory. Your Cloud Shell environment includes a directory
called `tutorial` that will store the configuration you will use for this
tutorial.

Inside of the `tutorial` directory you will find a file named `main.tf`.

<walkthrough-editor-open-file filePath="terraform-getting-started-gcp-cloud-shell/tutorial/main.tf">main.tf</walkthrough-editor-open-file>

First, configure the GCP provider. Add the following to `main.tf`.

```hcl
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 3.73.0"
    }
  }

  required_version = ">= 0.15.0"
}

provider "google" {
  project = "{{project-id}}"
  region  = "us-central1"
  zone    = "us-central1-c"
}
```

The `terraform` block configures Terraform, including defining providers and
configuring the required version of Terraform itself. A provider is responsible
for creating and managing resources. The `required_providers` block can include
multiple providers to manage resources from different providers.

The `provider` block is used to configure the named provider, in this case
`google`.

The `project` attribute should be set to the one you selected in the previous
step. You can review a list of your projects in the [cloud resource
manager](https://console.cloud.google.com/cloud-resource-manager)

### Initialization

The first command to run for a new configuration -- or after checking out an
existing configuration from version control -- is `terraform init`, which
initializes various local settings and data that will be used by subsequent
commands.

Initialize your new Terraform configuration by running the `terraform init`
command in the same directory as your main.tf file.

```bash
terraform init
```

```
Initializing the backend...

Initializing provider plugins...
- Finding hashicorp/google versions matching "~> 3.73.0"...
- Installing hashicorp/google v3.73.0...
- Installed hashicorp/google v3.73.0 (self-signed, key ID 34365D9472D7468F)

Partner and community providers are signed by their developers.
If you'd like to know more about provider signing, you can read about it here:
https://www.terraform.io/docs/cli/plugins/signing.html

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```

When you ran `terraform init`, Terraform downloaded the GCP provider plugin, and
installed it in a subdirectory of the current working directory.

## Apply Configuration

The `init` command does not provision any resources, it just sets up your
working directory to use the provider configuration you supplied. To provision
resources you will plan and apply your configuration. First, however, you must
enable the services your configuration will use in GCP.

### Enable Project Services

In this tutorial, you will be using the Google Compute Engine service to
provision your network and instance. You also need to enable the "OS Login"
service for authentication. You must enable these services for your project
before you can use them. In your Terraform configuration, use a module to manage
your project services. You can learn more about how this module works from the
[module
documentation](https://registry.terraform.io/modules/terraform-google-modules/project-factory/google/3.3.0/submodules/project_services).

Add the following Terraform configuration to `main.tf`.

```hcl
module "project_services" {
  source  = "terraform-google-modules/project-factory/google//modules/project_services"
  version = "3.3.0"

  project_id = "{{project-id}}"

  activate_apis = [
    "compute.googleapis.com",
    "oslogin.googleapis.com"
  ]

  disable_services_on_destroy = false
  disable_dependent_services  = false
}
```

The `project_services` module will enable the listed services for your project.

Before you can use a module, you must install it. Run `terraform get` to install
the `project_services` module now.

```bash
terraform get
```

```raw
Downloading terraform-google-modules/project-factory/google 3.3.0 for project_services...
- project_services in .terraform/modules/project_services/modules/project_services
```

After you install the module, apply your changes with `terraform apply`.

```bash
terraform apply
```

**Note:** Google Cloud Shell may prompt you to authorize this action before you
  can continue with the tutorial. Do so now.

Before it applies any changes, Terraform prints out the _execution plan_ which
describes the actions Terraform will take in order to change your infrastructure
to match the configuration. The plan for your configuration will look similar to
the following.

```raw
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # module.project_services.google_project_service.project_services[0] will be created
  + resource "google_project_service" "project_services" {
      + disable_dependent_services = false
      + disable_on_destroy         = false
      + id                         = (known after apply)
      + project                    = "learn-terraform-gcp"
      + service                    = "compute.googleapis.com"
    }

  # module.project_services.google_project_service.project_services[1] will be created
  + resource "google_project_service" "project_services" {
      + disable_dependent_services = false
      + disable_on_destroy         = false
      + id                         = (known after apply)
      + project                    = "learn-terraform-gcp"
      + service                    = "oslogin.googleapis.com"
    }

Plan: 2 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value:
```

Respond to the confirmation prompt with `yes` to apply the configuration. When
you do, Terraform will print out the status of the changes as they are applied.

```raw
  Enter a value: yes

module.project_services.google_project_service.project_services[0]: Creating...
module.project_services.google_project_service.project_services[1]: Creating...
module.project_services.google_project_service.project_services[0]: Still creating... [10s elapsed]
module.project_services.google_project_service.project_services[1]: Still creating... [10s elapsed]
module.project_services.google_project_service.project_services[0]: Still creating... [20s elapsed]
module.project_services.google_project_service.project_services[1]: Still creating... [20s elapsed]
module.project_services.google_project_service.project_services[0]: Still creating... [30s elapsed]
module.project_services.google_project_service.project_services[1]: Still creating... [30s elapsed]
module.project_services.google_project_service.project_services[0]: Still creating... [40s elapsed]
module.project_services.google_project_service.project_services[1]: Still creating... [40s elapsed]
module.project_services.google_project_service.project_services[0]: Still creating... [50s elapsed]
module.project_services.google_project_service.project_services[1]: Still creating... [50s elapsed]
module.project_services.google_project_service.project_services[0]: Still creating... [1m0s elapsed]
module.project_services.google_project_service.project_services[1]: Still creating... [1m0s elapsed]
module.project_services.google_project_service.project_services[0]: Creation complete after 1m1s [id=learn-terraform-gcp/compute.googleapis.com]
module.project_services.google_project_service.project_services[1]: Creation complete after 1m1s [id=learn-terraform-gcp/oslogin.googleapis.com]

Apply complete! Resources: 2 added, 0 changed, 0 destroyed.
```

Applying this configuration is the equivalent of navigating to the appropriate
page in the [api
library](https://console.developers.google.com/apis/library/compute.googleapis.com)
and enabling the services there.

You may also have noticed that the example configuration now refers to the
hard-coded project ID twice. You will remove that duplication soon when you
learn about Terraform _variables_.

## Provisioning Resources

Now add your first resource block to define a Virtual Private Cloud (VPC)
network.

Add the following to your `main.tf` file:

```hcl
resource "google_compute_network" "vpc_network" {
  name = "terraform-network"
  depends_on = [module.project_services]
}
```

The `resource` block defines a resource that exists within your infrastructure.
A resource might be a physical or virtual component such as a server, a logical
resource such as a Google App Engine application, or used to configure other
aspects of your environment.

You will use this network for resources you create later in this guide.

The resource block has two strings before opening the block: the resource type
and the resource name. In the example configuration, the resource type is
"google_compute_network" and the name is "vpc_network." The prefix of the type
maps to the provider. In this case "google_compute_network" tells Terraform that
the resource is managed by the "google" provider. The resource type and name
together form the resource ID, in this case
"google_compute_network.vpc_network". The resource can be referenced by this ID
in other parts of your configuration.

Within the resource block itself is configuration for that resource. This is
dependent on each resource provider and is fully documented within the
[providers reference](https://www.terraform.io/docs/providers/index.html).

The [GCP provider](https://www.terraform.io/docs/providers/google/index.html)
documents supported resources, including
[google_compute_network](https://www.terraform.io/docs/providers/google/r/compute_network.html).

There are a number of optional arguments available for VPCs, but for your
network the example configuration just specifies the name.

### Create Resources

Create the new resources by running `terraform apply` again.

```bash
terraform apply
```

Once again, Terraform will print the _execution plan_ and as you to confirm the
plan before making any changes to your infrastructure.

```raw
# ...

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # google_compute_network.vpc_network will be created
  + resource "google_compute_network" "vpc_network" {
      + auto_create_subnetworks         = true
      + delete_default_routes_on_create = false
      + gateway_ipv4                    = (known after apply)
      + id                              = (known after apply)
      + mtu                             = (known after apply)
      + name                            = "terraform-network"
      + project                         = (known after apply)
      + routing_mode                    = (known after apply)
      + self_link                       = (known after apply)
    }

# ...
```

The _execution plan_ describes which actions Terraform will take in order to
create infrastructure to match the configuration. The output format is similar
to the diff format generated by tools such as Git. The output has a `+` next to
`resource "google_compute_network" "vpc_network"`, meaning that Terraform will
create this resource. Beneath that, it prints out the attributes that will be
set. When the value displayed is `(known after apply)`, it means that the value
won't be known until the resource is created.

If the plan was created successfully, Terraform will now pause and wait for
approval before proceeding. If anything in the plan seems incorrect or
dangerous, it is safe to abort here with no changes made to your infrastructure.

In this case the plan looks acceptable, so respond to the confirmation prompt
with a `yes` to proceed.

Executing the plan will take time to complete, since Terraform will wait for the
network to be created successfully before reporting that the plan has been
applied successfully.

```raw
# ...

  Enter a value: yes

google_compute_network.vpc_network: Creating...
google_compute_network.vpc_network: Still creating... [10s elapsed]
google_compute_network.vpc_network: Still creating... [20s elapsed]
google_compute_network.vpc_network: Still creating... [30s elapsed]
google_compute_network.vpc_network: Creation complete after 32s [id=projects/learn-terraform-gcp/global/networks/terraform-network]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
```

You can review the network you have just provisioned in the GCP console. Make
sure you use the same region and project that you configured in the provider
configuration in `main.tf`.

When you apply changes to your configuration, Terraform keeps track of its
understanding of the resources it manages in a file called `terraform.tfstate`.
This state file is extremely important; it keeps track of Terraform's
understanding of the resources it created. We recommended that you use source
control for your configuration files, but the state file should not be stored in
source control. You can [setup Terraform
Cloud](https://learn.hashicorp.com/terraform/cloud-gettingstarted/tfc_overview)
to store and share the state with your teams.

## Inspect State

You can inspect the current state by running `terraform show`.

```bash
terraform show
```

```raw
# module.project_services.google_project_service.project_services[0]:
resource "google_project_service" "project_services" {
    disable_dependent_services = false
    disable_on_destroy         = false
    id                         = "learn-terraform-gcp/compute.googleapis.com"
    project                    = "learn-terraform-gcp"
    service                    = "compute.googleapis.com"
}

# module.project_services.google_project_service.project_services[1]:
resource "google_project_service" "project_services" {
    disable_dependent_services = false
    disable_on_destroy         = false
    id                         = "learn-terraform-gcp/oslogin.googleapis.com"
    project                    = "learn-terraform-gcp"
    service                    = "oslogin.googleapis.com"
}


# google_compute_network.vpc_network:
resource "google_compute_network" "vpc_network" {
    auto_create_subnetworks         = true
    delete_default_routes_on_create = false
    id                              = "projects/learn-terraform-gcp/global/networks/terraform-network"
    mtu                             = 0
    name                            = "terraform-network"
    project                         = "learn-terraform-gcp"
    routing_mode                    = "REGIONAL"
    self_link                       = "https://www.googleapis.com/compute/v1/projects/learn-terraform-gcp/global/networks/terraform-network"
```

When you created these resources with Terraform, it gathered a lot of
information about them. you can use these values to configure other resources or
outputs, which will be covered later in this tutorial.

## Update Infrastructure

In the previous section, you created your first infrastructure with Terraform: a
VPC network. In this section, you will modify your configuration and learn how
Terraform handles change.

Infrastructure is continuously evolving, and Terraform was built to help manage
and enact that change. As you change Terraform configurations, Terraform builds
an execution plan that only modifies what is necessary to reach your desired
state.

By using Terraform to change infrastructure, you can version control not only
your configurations but also your state, so you can track how your
infrastructure evolves over time.

### Add a Compute Instance

You can add new resources by adding them to your Terraform configuration and
running `terraform apply` to provision them.

First, add a google compute instance resource to `main.tf`.

```hcl
resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"

  boot_disk {
    initialize_params {
      image = "debian-cloud/debian-9"
    }
  }

  network_interface {
    network = google_compute_network.vpc_network.name
    access_config {
    }
  }

  allow_stopping_for_update = true
}
```

This resource includes a few more arguments. The name and machine type are
simple strings, but `boot_disk` and `network_interface` are more complex blocks.
You can review all of the available options for compute instances [in the
provider
documentation](https://www.terraform.io/docs/providers/google/r/compute_instance.html).
For this example, your compute instance will use a Debian operating system, and
will be connected to the VPC Network you created earlier. Notice how this
configuration refers to the network's name property with
`google_compute_network.vpc_network.name` --
`google_compute_network.vpc_network` is the resource ID, matching the values in
the block that defines the network, and `name` is a property of that resource.

The presence of the `access_config` block, even without any arguments, ensures
that the instance will be accessible over the internet.

Next, apply this change to create the compute instance.

```bash
terraform apply
```

Terraform will print an execution plan similar to the following.

```raw
# ...

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # google_compute_instance.vm_instance will be created
  + resource "google_compute_instance" "vm_instance" {
      + can_ip_forward       = false
      + cpu_platform         = (known after apply)
      + current_status       = (known after apply)
      + deletion_protection  = false
      + guest_accelerator    = (known after apply)
      + id                   = (known after apply)
      + instance_id          = (known after apply)
      + label_fingerprint    = (known after apply)
      + machine_type         = "f1-micro"
      + metadata_fingerprint = (known after apply)
      + min_cpu_platform     = (known after apply)
      + name                 = "terraform-instance"
      + project              = (known after apply)
      + self_link            = (known after apply)
      + tags_fingerprint     = (known after apply)
      + zone                 = (known after apply)

      + boot_disk {
          + auto_delete                = true
          + device_name                = (known after apply)
          + disk_encryption_key_sha256 = (known after apply)
          + kms_key_self_link          = (known after apply)
          + mode                       = "READ_WRITE"
          + source                     = (known after apply)

          + initialize_params {
              + image  = "debian-cloud/debian-9"
              + labels = (known after apply)
              + size   = (known after apply)
              + type   = (known after apply)
            }
        }

      + confidential_instance_config {
          + enable_confidential_compute = (known after apply)
        }

      + network_interface {
          + name               = (known after apply)
          + network            = "terraform-network"
          + network_ip         = (known after apply)
          + subnetwork         = (known after apply)
          + subnetwork_project = (known after apply)

          + access_config {
              + nat_ip       = (known after apply)
              + network_tier = (known after apply)
            }
        }

      + scheduling {
          + automatic_restart   = (known after apply)
          + min_node_cpus       = (known after apply)
          + on_host_maintenance = (known after apply)
          + preemptible         = (known after apply)

          + node_affinities {
              + key      = (known after apply)
              + operator = (known after apply)
              + values   = (known after apply)
            }
        }
    }

Plan: 1 to add, 0 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value:
```

Once again, answer `yes` to the confirmation prompt, and Terrform will create
the instance.

This is a fairly straightforward change - you added a "google_compute_instance"
resource named "vm_instance" to your configuration, and Terraform created the
resource in GCP.

## Change Resources

In addition to adding new resources, you can use Terraform to change existing
resources.

Add a "tags" argument to your "vm_instance" so that it looks like the following.

```hcl
resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"
  tags         = ["web", "dev"]

# ...
```

Run `terraform apply` again to update the instance.

```bash
terraform apply
```

```raw
# ...

  # google_compute_instance.vm_instance will be updated in-place
  ~ resource "google_compute_instance" "vm_instance" {
        id                   = "projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance"
        name                 = "terraform-instance"
      ~ tags                 = [
          + "dev",
          + "web",
        ]
        # (17 unchanged attributes hidden)



        # (3 unchanged blocks hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value:
```

The prefix `~` means that Terraform will update the resource in-place. Apply
this change now by responding `yes`, and Terraform will add the tags to your
instance.

## Destructive Changes

A destructive change is a change that requires the provider to replace the
existing resource rather than updating it. This usually happens because the
cloud provider doesn't support updating the resource in the way described by
your configuration.

Changing the disk image of an instance is one example of a destructive change.

Edit the `boot_disk` block inside the `vm_instance` resource in your
configuration file and change it to the following.

```hcl
  boot_disk {
    initialize_params {
      image = "cos-cloud/cos-stable"
    }
  }
```

This will change the boot disk from being a Debian 9 image to use Google's
Container-Optimized OS.

Now run `terraform apply` again. Terraform will print out a plan for this
change, then wait for you to confirm the change.

```bash
terraform apply
```

```raw
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # google_compute_instance.vm_instance must be replaced
-/+ resource "google_compute_instance" "vm_instance" {
      ~ cpu_platform         = "Intel Haswell" -> (known after apply)

# ...

      ~ boot_disk {
          ~ device_name                = "persistent-disk-0" -> (known after apply)
          + disk_encryption_key_sha256 = (known after apply)
          + kms_key_self_link          = (known after apply)
          ~ source                     = "https://www.googleapis.com/compute/v1/projects/learn-terraform-gcp/zones/us-central1-c/disks/terraform-instance" -> (known after apply)
            # (2 unchanged attributes hidden)

          ~ initialize_params {
              ~ image  = "https://www.googleapis.com/compute/v1/projects/debian-cloud/global/images/debian-9-stretch-v20210609" -> "cos-cloud/cos-stable" # forces replacement
              ~ labels = {} -> (known after apply)
              ~ size   = 10 -> (known after apply)
              ~ type   = "pd-standard" -> (known after apply)
            }
        }

# ...

Plan: 1 to add, 0 to change, 1 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value:
```

The prefix `-/+` means that Terraform will destroy and recreate the resource,
rather than updating it in-place. While some attributes can be updated in-place
(which are indicated with the `~` prefix), changing the boot disk image for an
instance requires recreating it. Terraform and the GCP provider handle these
details for you, and the execution plan makes it clear what Terraform will do.

Additionally, the execution plan tells you that the disk image change is what
required your instance to be replaced. Using this information, you can adjust
your changes to possibly avoid destroy/create updates if they are not acceptable
in some situations.

Once again, Terraform prompts for approval of the execution plan before
proceeding.

Answer `yes` to execute the planned steps.

```raw
# ...

  Enter a value: yes

google_compute_instance.vm_instance: Destroying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]
google_compute_instance.vm_instance: Still destroying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance, 10s elapsed]
google_compute_instance.vm_instance: Still destroying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance, 20s elapsed]
google_compute_instance.vm_instance: Destruction complete after 21s
google_compute_instance.vm_instance: Creating...
google_compute_instance.vm_instance: Still creating... [10s elapsed]
google_compute_instance.vm_instance: Creation complete after 12s [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.
```

As indicated by the execution plan, Terraform first destroyed the existing
instance and then created a new one in its place. You can run `terraform show`
to have Terraform print out the new values associated with this instance.

## Resource Dependencies

Most resources work with other parts of your infrastructure, either by being
dependent on other resources to function, such as an instance requiring a
virtual network, or using resource parameters to share information about one
resource with other resources.

Real-world infrastructure projects usually include many resources and resource
types. Terraform configurations can contain multiple resources, resource types,
and use multiple providers.

Now you will configure multiple resources and use resource attributes to
configure other resources.

### Assign a Static IP Address

Now add to your configuration by assigning a static IP to the VM instance in
`main.tf`.

```hcl
resource "google_compute_address" "vm_static_ip" {
  name = "terraform-static-ip"
}
```

This example is similar to the resources you have already defined. This time you
are creating an "google_compute_address" resource type. This resource type
allocates a [reserved IP
address](https://cloud.google.com/compute/docs/ip-addresses/#reservedaddress) to
your project.

Run `terraform plan` to review the changes Terraform will make before you apply
them.

```bash
terraform plan
```

```raw
# ...

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # google_compute_address.vm_static_ip will be created
  + resource "google_compute_address" "vm_static_ip" {
      + address            = (known after apply)
      + address_type       = "EXTERNAL"
      + creation_timestamp = (known after apply)
      + id                 = (known after apply)
      + name               = "terraform-static-ip"
      + network_tier       = (known after apply)
      + project            = (known after apply)
      + purpose            = (known after apply)
      + region             = (known after apply)
      + self_link          = (known after apply)
      + subnetwork         = (known after apply)
      + users              = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if you run "terraform apply" now.
```

Unlike `terraform apply`, the _plan_ command will only display what would be
changed, and never actually apply the changes directly. Notice that the only
change you have made so far is to add a static IP.

Next, attach the IP address to your instance.

Update the `network_interface` configuration for your instance to match the
following.

```hcl
  network_interface {
    network = google_compute_network.vpc_network.self_link
    access_config {
      nat_ip = google_compute_address.vm_static_ip.address
    }
  }
```

The
[access_config](https://www.terraform.io/docs/providers/google/r/compute_instance.html#access_config)
block has several optional arguments, and in this case you will set `nat_ip` to
be the static IP address defined by the resource
`google_compute_address.vm_static_ip`.

When Terraform reads this configuration, it will:

1. Ensure that `vm_static_ip` is created before `vm_instance`
1. Save the properties of `vm_static_ip` in the state
1. Set `nat_ip` to the value of `google_compute_address.vm_static_ip.address`

### Plan Changes

Run `terraform plan` again, but this time, save the plan into a file called
`static_ip`.

```bash
terraform plan -out static_ip
```

```raw
# ...

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
  ~ update in-place

Terraform will perform the following actions:

  # google_compute_address.vm_static_ip will be created
  + resource "google_compute_address" "vm_static_ip" {
      + address            = (known after apply)
      + address_type       = "EXTERNAL"
      + creation_timestamp = (known after apply)
      + id                 = (known after apply)
      + name               = "terraform-static-ip"
      + network_tier       = (known after apply)
      + project            = (known after apply)
      + purpose            = (known after apply)
      + region             = (known after apply)
      + self_link          = (known after apply)
      + subnetwork         = (known after apply)
      + users              = (known after apply)
    }

  # google_compute_instance.vm_instance will be updated in-place
  ~ resource "google_compute_instance" "vm_instance" {
        id                   = "projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance"
        name                 = "terraform-instance"
        tags                 = [
            "dev",
            "web",
        ]
        # (17 unchanged attributes hidden)


      ~ network_interface {
            name               = "nic0"
            # (4 unchanged attributes hidden)

          ~ access_config {
              ~ nat_ip       = "35.188.86.2" -> (known after apply)
                # (1 unchanged attribute hidden)
            }
        }


        # (3 unchanged blocks hidden)
    }

Plan: 1 to add, 1 to change, 0 to destroy.

───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

Saved the plan to: static_ip

To perform exactly these actions, run the following command to apply:
    terraform apply "static_ip"
```

Saving the plan this way ensures that you can apply exactly the same plan in the
future. When you apply the file created by the plan, Terraform will first check
to make sure the exact same set of changes will be made before applying the
plan.

In this case, the plan tells you that Terraform will create a new
`google_compute_address` resource and update the existing VM to use it.

### Apply Changes

Run `terraform apply "static_ip"` and Terraform will apply the plan you saved in
the previous step.

```bash
terraform apply "static_ip"
```

Terraform will display output similar to the following.

```raw
google_compute_address.vm_static_ip: Creating...
google_compute_address.vm_static_ip: Still creating... [10s elapsed]
google_compute_address.vm_static_ip: Creation complete after 11s [id=projects/learn-terraform-gcp/regions/us-central1/addresses/terraform-static-ip]
google_compute_instance.vm_instance: Modifying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]
google_compute_instance.vm_instance: Still modifying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance, 10s elapsed]
google_compute_instance.vm_instance: Still modifying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance, 20s elapsed]
google_compute_instance.vm_instance: Modifications complete after 23s [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]

Apply complete! Resources: 1 added, 1 changed, 0 destroyed.
```

Terraform created the static IP before modifying the VM instance. Due to the
interpolation expression that passes the IP address to the instance's network
interface configuration, Terraform is able to infer a dependency, and knows that
it must create the static IP before updating the instance.

## Implicit and Explicit Dependencies

Using the resource attributes defined in your configuration, Terraform can
automatically infer when one resource depends on another. In the example above,
the reference to `google_compute_address.vm_static_ip.address` creates an
_implicit dependency_ on the `google_compute_address` named `vm_static_ip`.

Terraform uses this dependency information to create a _dependency graph_ to
determine the correct order in which to create and update different resources.
In the example above, Terraform knows that the `vm_static_ip` must be created
before the `vm_instance` is updated to use it.

Sometimes there are dependencies between resources that are not visible to
Terraform. The `depends_on` argument can be added to any resource and accepts a
list of resources to create explicit dependencies for.

For example, when you created the vpc_network, you added an explicit dependency on
the project services you enabled earlier.

```hcl
resource "google_compute_network" "vpc_network" {
  name = "terraform-network"
  depends_on = [module.project_services]
}
```

This dependency ensures that the network will be created only after the project
services are enabled, and that the project services will not be disabled until
after the network is destroyed. There is not an implicit dependency on these two
resources, since there's no direct connection in the GCP API between the network
and the services you enabled.

## Provisioning

The compute instance you have created is based on the Google image given, but
has no additional software was installed or configuration applied.

GCP allows customers to manage their own [custom operating system images
](https://cloud.google.com/compute/docs/images/create-delete-deprecate-private-images).
This can be a great way to ensure the instances you provision with Terraform are
pre-configured based on your needs. [Packer](https://www.packer.io) is the
perfect tool for this and includes a [builder for
GCP](https://www.packer.io/docs/builders/googlecompute.html).

In general, we recommend that you use a tool like Packer so that your
infrastructure requires little or no provisioning after it's deployed. Managing
your infrastructure this way is sometimes called _immutable infrastructure_, and
can help ensure your infrastructure is more robust and fault tolerant.

That said, many infrastructures still require some sort of initialization or
software provisioning step. Terraform uses _provisioners_ to upload files, run
shell scripts, or install and trigger other software like configuration
management tools.

### Define a Provisioner

To define a provisioner, modify the resource block defining the first
`vm_instance` in your configuration to match the following.

```hcl
resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = "f1-micro"
  tags         = ["web", "dev"]

  provisioner "local-exec" {
    command = "echo ${google_compute_instance.vm_instance.name}:  ${google_compute_instance.vm_instance.network_interface[0].access_config[0].nat_ip} >> ip_address.txt"
  }

# ...
```

This adds a `provisioner` block within the `resource` block. Multiple
`provisioner` blocks can be added to define multiple provisioning steps.
Terraform supports [many
provisioners](https://www.terraform.io/docs/provisioners/index.html). This
example uses the `local-exec` provisioner.

The `local-exec` provisioner executes a command locally on the machine running
Terraform, not the VM instance itself.

You can use `${}` to include Terraform expressions within strings. Terraform
will interpolate the value of that expression into the string. Each VM instance
can have multiple network interfaces, so the example configuration refer to the
first one with `network_interface[0]` - counting starting from 0, as most
programming languages do. Each network interface can have multiple access_config
blocks as well, so once again the example configuration specifies the first one.

### Running Provisioners

Run `terraform apply` now. The results may be surprising.

```bash
terraform apply
```

Terraform will print output similar to the following.

```raw
google_project_service.service["compute.googleapis.com"]: Refreshing state... [id=learn-terraform-gcp/compute.googleapis.com]
google_project_service.service["oslogin.googleapis.com"]: Refreshing state... [id=learn-terraform-gcp/oslogin.googleapis.com]
google_compute_address.vm_static_ip: Refreshing state... [id=projects/learn-terraform-gcp/regions/us-central1/addresses/terraform-static-ip]
google_compute_network.vpc_network: Refreshing state... [id=projects/learn-terraform-gcp/global/networks/terraform-network]
google_compute_instance.vm_instance: Refreshing state... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]

Apply complete! Resources: 0 added, 0 changed, 0 destroyed.
```

Terraform found nothing to do - and if you check, you will find that Terraform
did not create the `ip_address.txt` file on the cloud shell filesystem.

Terraform treats provisioners differently from other resource arguments.
Terraform only executes provisioners when a resource is created. Adding a
provisioner to an existing resource will have no effect. To execute the
provisioner, first use `terraform taint` to tell Terraform to recreate the
instance.

```bash
terraform taint google_compute_instance.vm_instance
```

```raw
Resource instance google_compute_instance.vm_instance has been marked as tainted.
```

Terraform will destroy and recreate a _tainted_ resource during the next _apply_
step.

Run `terraform apply` to recreate the instance and execute the new provisioner.

```bash
terraform apply
```

Terraform will print out a plan to destroy and recreate the instance.

As before, respond to the confirmation prompt with `yes`.

```raw
# ...

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # google_compute_instance.vm_instance is tainted, so must be replaced
-/+ resource "google_compute_instance" "vm_instance" {

# ...

Plan: 1 to add, 0 to change, 1 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

google_compute_instance.vm_instance: Destroying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]
google_compute_instance.vm_instance: Still destroying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance, 10s elapsed]
google_compute_instance.vm_instance: Still destroying... [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance, 20s elapsed]
google_compute_instance.vm_instance: Destruction complete after 21s
google_compute_instance.vm_instance: Creating...
google_compute_instance.vm_instance: Still creating... [10s elapsed]
google_compute_instance.vm_instance: Provisioning with 'local-exec'...
google_compute_instance.vm_instance (local-exec): Executing: ["/bin/sh" "-c" "echo terraform-instance:  35.224.224.147 >> ip_address.txt"]
google_compute_instance.vm_instance: Creation complete after 13s [id=projects/learn-terraform-gcp/zones/us-central1-c/instances/terraform-instance]

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.
```

Verify that the provisioner worked correctly by inspecting the contents of the
`ip_address.txt` file.

```bash
cat ip_address.txt
```

```raw
terraform-instance: 35.224.224.147
```

It contains the IP address, just as you asked.

### Failed Provisioners and Tainted Resources

If a resource is successfully created but fails a provisioning step, Terraform
will error and mark the resource as _tainted_. A resource that is tainted still
exists, but should not be considered safe to use, since provisioning failed.

When you generate your next execution plan, Terraform will remove any tainted
resources and create new resources, attempting to provision them again after
creation.

### Destroy Provisioners

Provisioners can also be defined that run only during a destroy
operation. These are useful for performing system cleanup, extracting
data, etc.

For many resources, using built-in cleanup mechanisms is recommended
if possible (such as init scripts), but provisioners can be used if
necessary.

You can [review the provisioner
documentation](https://www.terraform.io/docs/provisioners) to learn more about
different kinds of provisioners.

## Variables

You now have enough Terraform knowledge to create useful configurations, but the
configuration still hardcodes the project name, zone, and other arguments. To
become truly shareable and version controlled, you will need to parameterize
your configurations. This page introduces input variables as a way to do this.

### Define Variables

First, convert a few of the hardcoded values into variables.

Edit the file called `variables.tf` to add the following contents.

```hcl
variable "project" { }

variable "region" {
  default = "us-central1"
}

variable "zone" {
  default = "us-central1-c"
}
```

Terraform loads all files ending in `.tf` in a directory, so it does not matter
to terraform where your variables are defined. We recommend defining them in
their own file to make your configuration easier to organize and understand.

This file defines three variables within your Terraform configuration. The first
variable, `project`, has an empty block: `{ }`. The other two set defaults. If a
default value is set, the variable is optional. Otherwise, the variable is
required. If you were to run `terraform plan` now, Terraform would prompt you
for the value for `project`.

### Use Variables in Configuration

Next, update the GCP provider configuration in `main.tf` to use these new
variables.

Replace the entire `provider "google"` block with the following.

```hcl
provider "google" {
  project = var.project
  region  = var.region
  zone    = var.zone
}
```

Variables are referenced with the `var.` prefix.

### Assigning Variables

There are several ways to assign variables, depending on your needs.

#### Command-line flags

You can set variables directly on the command-line with the `-var` flag. Any
command in Terraform that inspects the configuration accepts this flag, such as
`apply`, `plan`, and `refresh`.

```bash
terraform plan -var 'project={{project-id}}'
```

Setting variables this way will not save them, so you will have to set them
every time you run terraform.

#### From a file

To persist variable values, create a file and assign variables within
this file. Edit the file named `terraform.tfvars` with the following
contents.

```hcl
project = "{{project-id}}"
```

Terraform automatically loads all files which match `terraform.tfvars` or
`*.auto.tfvars` present in the current directory to populate variables. You can
also specify a file to load with the `-var-file` commandline argument.

These files use a similar syntax as Terraform configuration files for variable
values.

For security reasons, we recommend never saving usernames, passwords, and secret
keys to version control. Your terraform configuration will probably need these
secret values, though. One solution is to create a local secret variables file
and use `-var-file` to load it.

You can also use multiple `-var-file` arguments in a single command, with some
checked in to version control and others not checked in.

For example, you could have a `production.tfvars` for your production
environment, and keep secrets in a file called `secret.tfvars`, which you do not
check into source control, and apply your configuration with both files.

```raw
terraform apply \
  -var-file="secret.tfvars" \
  -var-file="production.tfvars"
```

#### From Environment Variables

Terraform will read environment variables in the form of `TF_VAR_name` to find
the value for a variable. For example, in this configuration the `TF_VAR_region`
environment variable could be used to set the `region` terraform variable.

#### UI Input

If you execute `terraform apply` with some variables unspecified, Terraform will
ask you to input their values interactively. These values are not saved, but
this provides a convenient workflow when getting started with Terraform. UI
Input is not recommended for everyday use of Terraform.

#### Variable Defaults

If no value is assigned to a variable via any of these methods and the variable
has a `default` key in its declaration, that value will be used for the
variable.

### Variable Types

Terraform supports a number of different variable types. The most common ones
are described below, and you can read the (Terraform
documentation)[https://www.terraform.io/docs/configuration/variables.html] for a
complete list.

#### Strings

If no type is specified, then Terraform assumes a variable is a _string_. Like
most programming languages, strings are just a sequence of characters. You can
also explicitly define a variable as a string.

Explicitly set the type of the `project` variable to be a string by updating
`variables.tf`. Replace the `variable "project"` block with the following.

```hcl
variable "project" {
  type = string
}
```

#### Numbers

A _number_, like a string, is pretty straightforward. Any valid integer or
floating point value is allowed. When processing your configuration, Terraform
will generally do the right thing when converting from a string to a number. So
defining the number type is more about ensuring that the correct type of input
is used.

```hcl
# Example - this variable is not used in this tutorial
variable "web_instance_count" {
  type    = number
  default = 1
}
```

#### Lists

Like lists or arrays found in many programming languages, a list is a sequence
of values.

Add a variable to `variables.tf` to define the CIDR network blocks to your
configuration as a list by either setting the default to a list, or setting the
type to `list`.

```hcl
variable "cidrs" {
  type = list
}
```

You can specify list values in a _tfvars_ file as well. Add the following to
`terraform.tfvars`.

```hcl
cidrs = [ "10.0.0.0/16", "10.1.0.0/16" ]
```

You will use these values later on in this tutorial.

#### Maps

Maps are a way to create variables that are lookup tables. Terraform maps are
similar to data structures found in programming languages, sometimes referred to
as maps or dictionaries.

In your configuration, the machine type is currently set to `f1-micro`. You
might want different machine types for different environments. You can use a map
to accomplish this.

Add a map that defines the machine types for each environment to your
`variables.tf` file.

```hcl
variable "environment" {
  type    = string
  default = "dev"
}

variable "machine_types" {
  type    = map
  default = {
    dev  = "f1-micro"
    test = "n1-highcpu-32"
    prod = "n1-highcpu-32"
  }
}
```

As with lists, a variable can have a map type assigned explicitly, or it can be
implicitly declared as a map by specifying a default value that is a map.

Use the `machine_types` map to set the machine type for the first `vm_instance`
in `main.tf`.

```hcl
resource "google_compute_instance" "vm_instance" {
  name         = "terraform-instance"
  machine_type = var.machine_types[var.environment]
  tags         = ["web", "dev"]

# ...
```

The square-bracket index notation used here is how you access values inside a
_map_ type variable.

Run `terraform plan`. Because the default value used for `environment` is the
same as the hard-coded value you replaced, Terraform will report that there are
no changes to apply.

Maps can also use a static value lookup directly. For example,
`var.machine_types["dev"]` will resolve to `"f1-micro"`.

##### Assigning Maps

The example configuration sets a default value for `var.machine_types`, but you
can also set maps using the `-var` and `-var-file` flags.

```bash
terraform apply -var 'machine_types={ dev = "f1-micro", test = "n1-standard-16", prod = "n1-standard-16" }'
```

Terraform will find no changes to apply, since these values match the hard-coded
ones in you configuration.

**Note:** Even if the map will be assigned using one of the above methods, the
  variable must be defined as a map in your configuration by setting its type to
  `map` or its default to `{}`.

You can also set the value of map variables in a `.tfvars` file.

You should now have several variable definitions in `variables.tf`, including `region`
and `machine_types`.

```hcl
# ...

variable "region" {
  default = "us-central1"
}

# ...

variable "machine_types" {
  type    = map
  default = {
    dev  = "f1-micro"
    test = "n1-highcpu-32"
    prod = "n1-highcpu-32"
  }
}
```

Specify values for these two variables in your `terraform.tfvars` file.

```hcl
region = "us-central1"

machine_types = {
  dev  = "f1-micro"
  test = "n1-highcpu-32"
  prod = "n1-highcpu-32"
}
```

Once again, running `terraform apply` at this point will have no effect, because
the value `"f1-micro"` from the map is the same as the hard coded value used
originally.

## Output Values

In the previous step, you learned to use input variables to parameterize your
Terraform configurations. In this step, you will use output variables to
organize data to be easily queried and returned to the Terraform user.

When building complex infrastructure, Terraform stores hundreds or thousands of
attribute values for all your resources. But as a user of Terraform, you may
only be interested in a few values, such as a load balancer IP, VPN address,
etc.

Outputs are a way to tell Terraform what data is important. This data is
outputted when `apply` is called, and can be queried using the `terraform
output` command.

### Define Outputs

Define an output to print out the static IP address that you created. Edit the
file called `outputs.tf` and add the following block.

```hcl
output "ip" {
  value = google_compute_address.vm_static_ip.address
}
```

**Note:** Just like `variables.tf`, this configuration could go in your
  `main.tf` file. `main.tf` file. We recommend putting outputs and variables in
  a separate files to to keep your configuration organized.

### Output Names

This defines an output variable named "ip". The name of the variable must
conform to Terraform variable naming conventions if it is to be used as an input
to other modules. The `value` field specifies what the value will be, In this
case, the example configuration outputs the `public_ip` attribute of the elastic
IP address you added earlier.

Multiple `output` blocks can be defined to specify multiple output variables.

### Viewing Outputs

Run `terraform refresh` to populate the output. This will refresh your state by
comparing it to your cloud infrastructure. In the process, it will also pick up
the new output.

```bash
terraform refresh
```

Terraform will print output similar to the following.

```raw
# ...

Outputs:

ip = "35.224.224.147"
```

Terraform will print out outputs whenever you run `terraform apply`. You can
also query the outputs with the `terraform output` command.

```bash
terraform output
```

```raw
ip = "35.224.224.147"
```

```bash
terraform output ip
```

```raw
"35.224.224.147"
```

This command is useful for scripts to extract outputs from your configuration.

In some cases, you may prefer that the output values be unquoted. You can have
Terraform print out unquoted strings with the `-raw` flag.

```bash
terraform output -raw ip
```

```raw
35.224.224.147
```

You can use the `-raw` flag when you pass Terraform output values to shell
commands or other automation.

## Modules

Up to this point, you have been managing infrastructure with Terraform by adding
resources to your Terraform configurations directly. As your infrastructure
grows, this practice has a few key problems: a lack of organization, a lack of
reusability, and difficulties in management for teams.

_Modules_ in Terraform are self-contained packages of Terraform configurations
that are managed as a group. Modules are used to create reusable components,
improve organization, and to treat pieces of infrastructure as a black box.

This section of the getting started will cover the basics of using modules.
Using and creating modules is covered in more detail in the [modules
collection](https://learn.hashicorp.com/collections/terraform/modules) on
HashiCorp Learn.

### Use a Network Module

The [Terraform Registry](https://registry.terraform.io/) includes a directory of
ready-to-use modules for various common purposes, which can serve as larger
building-blocks for your infrastructure. Earlier in this tutorial, you used a
module to configure the services to enable for this project.

In this example, you will use a [network module for
GCP](https://registry.terraform.io/modules/terraform-google-modules/network/google/latest)
to manage a more advanced networking configuration.

Use a module to define a network by adding the following to your `main.tf` file.

```hcl
module "network" {
  source  = "terraform-google-modules/network/google"
  version = "3.3.0"
  depends_on = [module.project_services]

  network_name = "terraform-vpc-network"
  project_id   = var.project

  subnets = [
    {
      subnet_name   = "subnet-01"
      subnet_ip     = var.cidrs[0]
      subnet_region = var.region
    },
    {
      subnet_name   = "subnet-02"
      subnet_ip     = var.cidrs[1]
      subnet_region = var.region

      subnet_private_access = "true"
    },
  ]

  secondary_ranges = {
    subnet-01 = []
    subnet-02 = []
  }
}
```

The `module` block begins with the name of the module. This is similar to a
`resource` block: it defines a name used within this configuration -- in this
case, `"network"` -- and a set of input values that are listed in [the module's
"Inputs"
documentation](https://registry.terraform.io/modules/terraform-google-modules/network/google/latest?tab=inputs).

The `source` attribute is the only mandatory argument for all modules. It tells
Terraform where the module can be retrieved. Terraform will install and manage
modules for you from the Terraform registry, source control systems like GitHub,
a URL, or your local filesystem.

The other attributes in the `module` are inputs to your module. This module
supports many additional inputs, which you can read about in its documentation,
but all are optional and have reasonable defaults.

**Note:** This configuration uses a different name for the new network to avoid
  errors when replacing the old network configuration with the new one.

This will configure a simple network with two subnets. Now replace the original
network configuration with the one you just added.

Comment out or delete the `vpc_network` resource block.

```hcl
# Remove or #comment out:
#
# resource "google_compute_network" "vpc_network" {
#   name = "terraform-network"
#   depends_on = [module.project_services]
# }
```

You will also need to refer to the new network differently. Inside of the
resource block for your `vm_instance`, update the `network_interface` section to
use the new network and one of the subnets.

```hcl
# ...
  network_interface {
# Replace this line:
#   network = google_compute_network.vpc_network.name
# With this these two:
    network    = module.network.network_name
    subnetwork = module.network.subnets_names[0]
# Leave the rest of the instance configuration unchanged
    access_config {
      nat_ip = google_compute_address.vm_static_ip.address
    }
  }
# ...
```

Now your instance's configuration is referring to the _output_ of the network
module to configure its network and subnetwork. You can review the output values
for modules in the [module registry
documentaton](https://registry.terraform.io/modules/terraform-google-modules/network/google/latest?tab=outputs).

Since the instance will now be located in a different network, Terraform will
need to destroy and recreate it.

### Install the Module

Terraform modules are essentially pre-packaged Terraform configuration. They
need to be installed on your system before you can use them in your
configuration. You can do that with the `terraform init` command.

Install the network module by running `terraform init` now.

```bash
terraform init
```

```raw
Initializing modules...
Downloading terraform-google-modules/network/google 3.3.0 for network...
- network in .terraform/modules/network
- network.firewall_rules in .terraform/modules/network/modules/firewall-rules
- network.routes in .terraform/modules/network/modules/routes
- network.subnets in .terraform/modules/network/modules/subnets
- network.vpc in .terraform/modules/network/modules/vpc

Initializing the backend...

Initializing provider plugins...
- Finding hashicorp/google-beta versions matching "~> 3.45"...
- Reusing previous version of hashicorp/google from the dependency lock file
- Installing hashicorp/google-beta v3.73.0...
- Installed hashicorp/google-beta v3.73.0 (self-signed, key ID 34365D9472D7468F)
- Using previously-installed hashicorp/google v3.73.0

Partner and community providers are signed by their developers.
If you'd like to know more about provider signing, you can read about it here:
https://www.terraform.io/docs/cli/plugins/signing.html

Terraform has made some changes to the provider dependency selections recorded
in the .terraform.lock.hcl file. Review those changes and commit them to your
version control system if they represent changes you intended to make.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```

Now the module is installed on your system and Terraform can use it to provision
resources. You need to run `terraform init` or `terraform get` every time you
add a new module or want to change module versions.

If you like, you can run `terraform plan` at this point to review what changes
will be applied. Notice that your instance will be destroyed and recreated
because it will move to the new network.

### Apply Changes

Apply your changes to replace the original network resource with the one managed
by the new module.

Run `terraform apply`.

```bash
terraform apply
```

Confirm the apply with a `yes`.

The output is similar to when your configuration defined the resources directly,
but the resources IDs now have the module name prefixed to their names.

### Module Outputs

Just as the module instance has input arguments, module can also produce
_output_ values, similar to resource attributes. The example configuration uses
two of them when configuring your instance - the name of the network and one of
your subnets.

One of the other outputs for this module is called `subnets_ips`, and its value
describes the IPs and CIDR blocks created for your network.

You can reference a module's output with the expression `module.<MODULE
NAME>.<OUTPUT NAME>`. Like most expressions, this value can be used almost
anywhere: in another resource, to configure another module, etc. To demonstrate,
try referencing it in a root-level output, so that Terraform will display it
after an apply.

Add an output for the VPC's subnet IP addresses to `outputs.tf`.

```hcl
output "vpc_network_subnets_ips" {
  value = module.network.subnets_ips
}
```

Run `terraform refresh` again, and Terraform will print the new output value.

```bash
terraform refresh
```

Terraform will make no changes to your infrastructure, but it will print out the
value of the "vpc_network_subnets_ips" output.

```raw
Outputs:

ip = "35.224.224.147"
vpc_network_subnets_ips = [
  "10.0.0.0/16",
  "10.1.0.0/16",
]
```

Infrastructure configuration can be complex and often repetitive. Modules
provide a way for you to re-use and share standard configuration patterns.

## Destroy

As a final step, you will want to destroy the infrastructure you created for
this tutorial, to avoid being charged for it in the future.

To do so, run `terraform destroy`.

```bash
terraform destroy
```

Respond to the confirmation prompt with a `yes`. Terraform will destroy all
resources managed by your configuration.

## Next Steps

This concludes the getting started tutorial for Terraform. You have used
Terraform to create, update, and destroy infrastructure on Google Cloud
Platform.

As a next step, check out the following resources.

- [Terraform Documentation](https://www.terraform.io/docs/index.html) - The
  documentation is an in-depth reference guide to all the features of Terraform,
  including technical details about the internals of how Terraform operates.

- [Google Provider
  Documentation](https://www.terraform.io/docs/providers/google/provider_reference.html)
  The Google provider documentation includes everything you need to configure
  and provision GCP resources.

- [Examples](https://www.terraform.io/intro/examples/index.html) - The examples
  have more full featured configuration files, showing some of the possibilities
  with Terraform.

- [Terraform Cloud](/terraform/cloud-gettingstarted/tfc_overview) - Terraform
  Cloud is a hosted application that can be used to store Terraform state and
  execute Terraform commands.
